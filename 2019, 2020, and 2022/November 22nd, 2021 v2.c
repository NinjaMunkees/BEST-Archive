#pragma config(Motor,  port2,           LMotor,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           RMotor,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           LElevator,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           RElevator,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           RDoor,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           LDoor,         tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*===================================================================================*/
task Chasis()
{
	float left, right;	//Variables for calculating
	while (true)
	{
		if(abs(vexRT[Ch3]) < 10 && abs(vexRT[Ch2]) < 10)	//To account for any human flinching
		{
			motor[LMotor] = 0;
			motor[RMotor] = 0;
		}
		else
		{
			left = pow(vexRT[Ch3], 3)/pow(127, 2);	//Slope calculation for smooth speed increase
			right = pow(vexRT[Ch2], 3)/pow(127, 2);

			if(left > 127)	//Crutches to ensure we don't overpower the motors
			{
				left = 127;
			}
			else if(left < -127)
			{
				left = -127;
			}
			if(right > 127)
			{
				right = 127;
			}
			else if(right < -127)
			{
				right = -127;
			}
			motor[LMotor] = left;	//Send the values to the motors
			motor[RMotor] = right;
		}
	}
}

/*===================================================================================*/

task Elevator()
{
	while(true)
	{
		if(vexRT[Btn6U] == true)	//Raise the elevator
		{
			motor[LElevator] = -75;
			motor[RElevator] = -127;
		}
		else if(vexRT[Btn6D] == true)	//Lower the elevator
		{
			motor[LElevator] = 75;
			motor[RElevator] = 127;
		}
		else	//When no input is coming from the controllers, sets motors to 0.
		{
			motor[LElevator] = 0;
			motor[RElevator] = 0;
		}
	}
}

/*===================================================================================*/

task Trapdoor()
{
	motor[LDoor] = 300;	//Closing the trapdoors as soon as the robot is activated regardless of driver input
	motor[RDoor] = 300;
	while(true)
	{
		if(vexRT[Btn8R] == true)	//Close
		{
			motor[RDoor] = 300;
			motor[LDoor] = 300;
		}
		else if(vexRT[Btn8L] == true)	//Open
		{
			motor[RDoor] = -20;
			motor[LDoor] = -35;
		}
	}
}

/*===================================================================================*/

task Autonomous()	//Autonomous program
{
	motor[LMotor] = 70;	//Forward
	motor[RMotor] = 127;
	wait1Msec(((7500 - nImmediateBatteryLevel) * 0.12 + 540) * 4); // Takes median battery level and scales our movement based on input
	motor[LMotor] = 115;	//Right turn
	motor[RMotor] = -127;
	wait1Msec((7500 - nImmediateBatteryLevel) * 0.16 + 540);
	motor[LMotor] = 70;	//Forward
	motor[RMotor] = 127;
	wait1Msec(((7500 - nImmediateBatteryLevel) * 0.1 + 540) * 4);
	motor[LMotor] = 0;	//Stop
	motor[RMotor] = 0;
}

/*===================================================================================*/

task main()	//Main task
{
	startTask(Chasis);
	startTask(Elevator);
	startTask(Trapdoor);

	bool Auto = false;	//Auto flag

	while(true)
	{
		if(vexRT[Btn8U] == true && Auto == false)	//Start Auto
		{
			stopTask(Chasis);	//To keep the drive train from interfering with the autonmous program
			startTask(Autonomous);
			Auto = true;
		}
		else if(Auto == true && (abs(vexRT[Ch3]) > 10 || abs(vexRT[Ch2]) > 10 || abs(vexRT[Ch1]) > 0 || abs(vexRT[Ch4]) > 10))	//Emergency stop
		{
			stopTask(Autonomous);
			startTask(Chasis);	//Start the drive program
			Auto = false;
		}
	}
}
